#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl4,  SonarF,         sensorSONAR_inch)
#pragma config(Sensor, dgtl6,  SonarL,         sensorSONAR_inch)
#pragma config(Sensor, dgtl8,  SonarR,         sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           R_Motor,       tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port10,          L_Motor,       tmotorVex269, openLoop, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//R_Motor = right motor
//L_Motor = left motor

//Arbitrary grid dimensions
const int x_size = 25;
const int y_size = 19;

//0  = open space
//1  = barrier
//2  = goal
//99 = robot

int map[x_size][y_size] =
{{0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
 {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
 {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
 {0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
 {1,1,1,1,99,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1},
 {1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
 {1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
 {0,0,0,1,1,1,1,1,1,1,0,0,0,0,2,0,0,0,0},
 {0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0},
 {0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0}};

//determines if the direction is available
//return value 0 is false, 1 is true
bool can_proceed(int cur, int next, int x, int y)
{
    if(abs(cur - next) == 0)
      {
        if(SensorValue(SonarF) < 12) //can not proceed this direction
           { map[x][y] = 1;
             return 0;
           }
      }

    if(abs(cur - next) == 2)
        return 1;

    if(((cur - next) < 0)&&(next != 3))
    { if(SensorValue(SonarL) < 12)
        { map[x][y] = 1;
          return 0;
        }
    }
      else if(((cur - next) < 0)&&(next == 3))
    {
        if(SensorValue(SonarR) < 12)
        { map[x][y] = 1;
          return 0;
        }
    }

    if(((cur - next) > 0)&&(cur != 3))
    {if(SensorValue(SonarR) < 12)
        { map[x][y] = 1;
          return 0;
        }
    }
      else if(((cur - next) < 0)&&(next == 3))
    {
      if(SensorValue(SonarL) < 12)
        { map[x][y] = 1;
          return 0;
        }
    }

    return 1;

}

//FORWARD for a variable number of grid blocks
void moveForward(int blocks)
{
	//convert number of blocks to encoder counts
	//wheel circumference = 17.6 cm
	//one block = 23.7 cm

	/*int countsToTravel = 400 * blocks; //(23.7/17.6)*(360)*blocks;

	nMotorEncoder[R_Motor] = 0;
	nMotorEncoder[L_Motor] = 0;

	//This may need fixed//
	while(nMotorEncoder[R_Motor]< countsToTravel && nMotorEncoder[L_Motor] < countsToTravel)
	{*/
		motor[R_Motor] = 40;
		motor[L_Motor] = -40;
		wait1Msec(1250);
	//}

		motor[R_Motor] = 0;
		motor[L_Motor] = 0;
		wait1Msec(500);

}

//LEFT point turn 90 degrees
void turnLeft90()
{
	motor[R_Motor] = 50;
	motor[L_Motor] = 50;
	wait1Msec(1195);

	motor[R_Motor]=0;
    motor[L_Motor]=0;
	wait1Msec(500);
}

//RIGHT point turn 90 degrees
void turnRight90()
{
	motor[R_Motor] = -50;
	motor[L_Motor] = -50;
	wait1Msec(1195);

	motor[R_Motor]=0;
	motor[L_Motor] = 0;
	wait1Msec(500);
}

//SEARCH FUNCTION
void WavefrontSearch()
{
    int goal_x, goal_y;
	bool foundWave = true;
	int currentWave = 2; //searching for goal

	while(foundWave == true)
	{
		foundWave = false;

		for(int y = 0; y < y_size; y++)
		{
			for(int x = 0; x < x_size; x++)
			{
				if(map[x][y] == currentWave)
				{
					foundWave = true;
					goal_x = x;
					goal_y = y;

					if(goal_x > 0) //WEST
						if(map[goal_x - 1][goal_y] == 0)
							map[goal_x-1][goal_y] = currentWave + 1;

					if(goal_x < (x_size - 1)) //EAST
						if(map[goal_x+1][goal_y] == 0)
							map[goal_x+1][goal_y] = currentWave + 1;

					if(goal_y > 0)//SOUTH
						if(map[goal_x][goal_y-1] == 0)
							map[goal_x][goal_y-1] = currentWave + 1;

					if(goal_y < (y_size - 1)) //NORTH
						if(map[goal_x][goal_y+1] == 0)
                            map[goal_x][goal_y+1] = currentWave + 1;
				}
			}
		}

		currentWave++;
		wait1Msec(500);
	}
}

//NAVIGATION FUNCTION
void NavigateToGoal()
{
	int robot_x, robot_y; //current position storage
   // Path paths[3]; //3 paths we will consider

    robot_x = 1;
    robot_y = 2;

	//goal is found, efficient path being planned
	int current_x = robot_x;
	int current_y = robot_y;
	int current_facing = 0;
	int next_Direction = 0;
	int current_low = 99;

	while(current_low > 2)
	{
		current_low = 99;
		next_Direction = current_facing;
		int Next_X = 0;
		int Next_Y = 0;
        int count = 0;

		//check west part of array
		if(current_x > 0)
			if(map[current_x-1][current_y] < current_low && map[current_x-1][current_y] != 1) //Is current space occupied
            {
                next_Direction = 3;
              if(can_proceed(current_facing, next_Direction, current_x-1, current_y) == 0)
              { current_low = map[current_x-1][current_y];
				Next_X = current_x-1;
				Next_Y = current_y;
                count = 0;
              }
			}
            else count++;

			//check east part of array
			if(current_x < (x_size -1))
				if(map[current_x+1][current_y] < current_low && map[current_x+1][current_y] != 1) //Is current space occupied
				{
                    next_Direction = 1;
                    if(can_proceed(current_facing, next_Direction, current_x+1, current_y) == 0)
                    { current_low = map[current_x+1][current_y];
                      Next_X = current_x+1;
                      Next_Y = current_y;
                      count = 0;
                    }
				}
                else count++;

				//check south
				if(current_y > 0)
					if(map[current_x][current_y-1] < current_low && map[current_x][current_y-1] != 1)
					{
                        next_Direction = 2;
                      if(can_proceed(current_facing, next_Direction, current_x, current_y-1) == 0)
                      { current_low = map[current_x][current_y-1];
						Next_X = current_x;
						Next_Y = current_y-1;
                        count = 0;
                      }
					}
                    else count++;

					//check north
					if(current_y < (y_size - 1))
						if(map[current_x][current_y+1] < current_low && map[current_x][current_y+1] != 1)
                        {
                            next_Direction = 0;
                          if(can_proceed(current_facing, next_Direction, current_x, current_y+1) == 0)
                            { current_low = map[current_x][current_y+1];
                              Next_X = current_x;
                              Next_Y = current_y+1;
                              count = 0;
                            }
						}
                        else count++;

						//The robot now knows which direction to head

						current_x = Next_X;
						current_y = Next_Y;


						//The robots new direction
						while(current_facing != next_Direction)
						{
							if (current_facing > next_Direction)
							{
								turnLeft90();
								current_facing--;
							}

							else if(current_facing < next_Direction)
							{
								turnRight90();
								current_facing++;
							}
						}

                        if((current_x == Next_X)&&(current_y == Next_Y))
                        {
                            if(count == 4)
                                current_low++;

                            if(count > 4) //there is no where to go
                                continue;
                        }
                        else
                        { moveForward(1);
                          wait1Msec(500);
                        }
                    }
                }

task main()
{
	WavefrontSearch();
	NavigateToGoal();
}
